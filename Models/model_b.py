# -*- coding: utf-8 -*-
"""Model B.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RpD1FO6W504lMPfUIqCrsTUoCsMhERUc
"""

!pip install tensorflow

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, KFold, cross_val_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.multioutput import MultiOutputRegressor
from sklearn.metrics import mean_squared_error, r2_score
import tensorflow as tf

# Load the dataset (adjust file path as needed)
file_path = 'yield_df.csv'
yield_df = pd.read_csv(file_path)

# 1. Data Quality Check and Handling Missing Values
# Handling missing values by filling with mean
yield_df['hg/ha_yield'].fillna(yield_df['hg/ha_yield'].mean(), inplace=True)
yield_df['avg_temp'].fillna(yield_df['avg_temp'].mean(), inplace=True)
yield_df['average_rain_fall_mm_per_year'].fillna(yield_df['average_rain_fall_mm_per_year'].mean(), inplace=True)

# 2. Feature Engineering
yield_df['yield_squared'] = yield_df['hg/ha_yield'] ** 2  # Polynomial feature
yield_df['yield_log'] = np.log1p(yield_df['hg/ha_yield'])  # Log transformation
yield_df['yield_temp_interaction'] = yield_df['hg/ha_yield'] * yield_df['avg_temp']  # Interaction term

# Selecting features and target variables
X = yield_df[['hg/ha_yield', 'yield_squared', 'yield_log', 'yield_temp_interaction', 'Item']]
y = yield_df[['avg_temp', 'average_rain_fall_mm_per_year']]

# Preprocessing for numerical and categorical features
numerical_features = ['hg/ha_yield', 'yield_squared', 'yield_log', 'yield_temp_interaction']
categorical_features = ['Item']

scaler = StandardScaler()
X[numerical_features] = scaler.fit_transform(X[numerical_features])

encoder = OneHotEncoder()
X_encoded = encoder.fit_transform(X[categorical_features]).toarray()

X_combined = np.hstack([X[numerical_features].values, X_encoded])

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X_combined, y, test_size=0.2, random_state=42)

# 3. Neural Network Model with Increased Complexity
nn_model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(X_train.shape[1],)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(2)  # Two output values (temperature and rainfall)
])

nn_model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                 loss='mse',
                 metrics=['mae'])

# Training the model with validation split
history = nn_model.fit(X_train, y_train, validation_split=0.2, epochs=100, batch_size=32, verbose=1)

# Evaluating the model
nn_loss, nn_mae = nn_model.evaluate(X_test, y_test, verbose=0)
y_pred_nn = nn_model.predict(X_test)

# 4. Hyperparameter Tuning with Random Forest (Tree-based Model)
rf_model = MultiOutputRegressor(RandomForestRegressor(n_estimators=200, max_depth=10, random_state=42))
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

# 5. Model Evaluation
def evaluate_model(y_true, y_pred):
    mse_temp = mean_squared_error(y_true['avg_temp'], y_pred[:, 0])
    mse_rainfall = mean_squared_error(y_true['average_rain_fall_mm_per_year'], y_pred[:, 1])
    r2_temp = r2_score(y_true['avg_temp'], y_pred[:, 0])
    r2_rainfall = r2_score(y_true['average_rain_fall_mm_per_year'], y_pred[:, 1])
    return mse_temp, mse_rainfall, r2_temp, r2_rainfall

mse_temp_nn, mse_rainfall_nn, r2_temp_nn, r2_rainfall_nn = evaluate_model(y_test, y_pred_nn)
mse_temp_rf, mse_rainfall_rf, r2_temp_rf, r2_rainfall_rf = evaluate_model(y_test, y_pred_rf)

print("Neural Network Model Evaluation Metrics:")
print(f"Temperature Prediction - MSE: {mse_temp_nn:.2f}, R²: {r2_temp_nn:.2f}")
print(f"Rainfall Prediction - MSE: {mse_rainfall_nn:.2f}, R²: {r2_rainfall_nn:.2f}")

print("\nRandom Forest Model Evaluation Metrics:")
print(f"Temperature Prediction - MSE: {mse_temp_rf:.2f}, R²: {r2_temp_rf:.2f}")
print(f"Rainfall Prediction - MSE: {mse_rainfall_rf:.2f}, R²: {r2_rainfall_rf:.2f}")

# 6. Cross-Validation with Random Forest
kf = KFold(n_splits=5, shuffle=True, random_state=42)
rf_scores = cross_val_score(RandomForestRegressor(n_estimators=200, max_depth=10, random_state=42),
                            X_combined, y.values, cv=kf, scoring='neg_mean_squared_error')
print(f"\nRandom Forest Cross-Validation Scores (MSE): {rf_scores.mean():.2f}")

# Prediction function for new input using Neural Network
def predict_temperature_humidity_nn(crop, yield_value):
    yield_squared = yield_value ** 2
    yield_log = np.log1p(yield_value)
    yield_temp_interaction = yield_value * np.mean(y_train['avg_temp'])  # Example interaction term

    input_data = pd.DataFrame({
        'hg/ha_yield': [yield_value],
        'yield_squared': [yield_squared],
        'yield_log': [yield_log],
        'yield_temp_interaction': [yield_temp_interaction],
        'Item': [crop]
    })

    # Preprocess input data
    input_data[numerical_features] = scaler.transform(input_data[numerical_features])
    input_encoded = encoder.transform(input_data[categorical_features]).toarray()
    input_combined = np.hstack([input_data[numerical_features].values, input_encoded])

    # Predict using the trained model
    prediction = nn_model.predict(input_combined)
    predicted_temp, predicted_rainfall = prediction[0]

    return predicted_temp, predicted_rainfall

# Example usage
sample_crop = 'Maize'
sample_yield = 0
predicted_temp, predicted_rainfall = predict_temperature_humidity_nn(sample_crop, sample_yield)

print(f"Predicted Temperature (NN): {predicted_temp:.2f}°C")
print(f"Predicted Rainfall (Humidity proxy, NN): {predicted_rainfall:.2f} mm/year")

# Example usage
sample_crop = 'Maize'
sample_yield = 0
predicted_temp, predicted_rainfall = predict_temperature_humidity_nn(sample_crop, sample_yield)

print(f"Predicted Temperature (NN): {predicted_temp:.2f}°C")
print(f"Predicted Rainfall (Humidity proxy, NN): {predicted_rainfall:.2f} mm/year")

# Calculate accuracy as a percentage based on R² score
nn_temp_accuracy = r2_temp_nn * 100
nn_rainfall_accuracy = r2_rainfall_nn * 100

rf_temp_accuracy = r2_temp_rf * 100
rf_rainfall_accuracy = r2_rainfall_rf * 100

# Display accuracy percentages
print("Neural Network Model Accuracy (Percentage):")
print(f"Temperature Prediction Accuracy: {nn_temp_accuracy:.2f}%")
print(f"Rainfall Prediction Accuracy: {nn_rainfall_accuracy:.2f}%")

print("\nRandom Forest Model Accuracy (Percentage):")
print(f"Temperature Prediction Accuracy: {rf_temp_accuracy:.2f}%")
print(f"Rainfall Prediction Accuracy: {rf_rainfall_accuracy:.2f}%")

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, KFold, cross_val_score
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestRegressor
from sklearn.multioutput import MultiOutputRegressor
from sklearn.metrics import mean_squared_error, r2_score
import tensorflow as tf

# Load the dataset (adjust file path as needed)
file_path = 'yield_df.csv'
yield_df = pd.read_csv(file_path)

# Data Quality Check and Handling Missing Values
yield_df['hg/ha_yield'].fillna(yield_df['hg/ha_yield'].mean(), inplace=True)
yield_df['avg_temp'].fillna(yield_df['avg_temp'].mean(), inplace=True)
yield_df['average_rain_fall_mm_per_year'].fillna(yield_df['average_rain_fall_mm_per_year'].mean(), inplace=True)

# Feature Engineering
yield_df['yield_squared'] = yield_df['hg/ha_yield'] ** 2  # Polynomial feature
yield_df['yield_log'] = np.log1p(yield_df['hg/ha_yield'])  # Log transformation
yield_df['yield_temp_interaction'] = yield_df['hg/ha_yield'] * yield_df['avg_temp']  # Interaction term

# Selecting features (X) and target variables (y) including Year as a target
X = yield_df[['hg/ha_yield', 'yield_squared', 'yield_log', 'yield_temp_interaction', 'Item']]
y = yield_df[['Year', 'avg_temp', 'average_rain_fall_mm_per_year']]

# Preprocessing for numerical and categorical features
numerical_features = ['hg/ha_yield', 'yield_squared', 'yield_log', 'yield_temp_interaction']
categorical_features = ['Item']

scaler = StandardScaler()
X[numerical_features] = scaler.fit_transform(X[numerical_features])

encoder = OneHotEncoder()
X_encoded = encoder.fit_transform(X[categorical_features]).toarray()

X_combined = np.hstack([X[numerical_features].values, X_encoded])

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X_combined, y, test_size=0.2, random_state=42)

# Neural Network Model with Increased Complexity
nn_model = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(X_train.shape[1],)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(3)  # Three output values (Year, temperature, and rainfall)
])

nn_model.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                 loss='mse',
                 metrics=['mae'])

# Training the model with validation split
history = nn_model.fit(X_train, y_train, validation_split=0.2, epochs=100, batch_size=32, verbose=1)

# Evaluating the model
nn_loss, nn_mae = nn_model.evaluate(X_test, y_test, verbose=0)
y_pred_nn = nn_model.predict(X_test)

# Hyperparameter Tuning with Random Forest (Tree-based Model)
rf_model = MultiOutputRegressor(RandomForestRegressor(n_estimators=200, max_depth=10, random_state=42))
rf_model.fit(X_train, y_train)
y_pred_rf = rf_model.predict(X_test)

# Model Evaluation
def evaluate_model(y_true, y_pred):
    mse_year = mean_squared_error(y_true['Year'], y_pred[:, 0])
    mse_temp = mean_squared_error(y_true['avg_temp'], y_pred[:, 1])
    mse_rainfall = mean_squared_error(y_true['average_rain_fall_mm_per_year'], y_pred[:, 2])

    r2_year = r2_score(y_true['Year'], y_pred[:, 0])
    r2_temp = r2_score(y_true['avg_temp'], y_pred[:, 1])
    r2_rainfall = r2_score(y_true['average_rain_fall_mm_per_year'], y_pred[:, 2])

    return mse_year, mse_temp, mse_rainfall, r2_year, r2_temp, r2_rainfall

mse_year_nn, mse_temp_nn, mse_rainfall_nn, r2_year_nn, r2_temp_nn, r2_rainfall_nn = evaluate_model(y_test, y_pred_nn)
mse_year_rf, mse_temp_rf, mse_rainfall_rf, r2_year_rf, r2_temp_rf, r2_rainfall_rf = evaluate_model(y_test, y_pred_rf)

print("Neural Network Model Evaluation Metrics:")
print(f"Year Prediction - MSE: {mse_year_nn:.2f}, R²: {r2_year_nn:.2f}")
print(f"Temperature Prediction - MSE: {mse_temp_nn:.2f}, R²: {r2_temp_nn:.2f}")
print(f"Rainfall Prediction - MSE: {mse_rainfall_nn:.2f}, R²: {r2_rainfall_nn:.2f}")

print("\nRandom Forest Model Evaluation Metrics:")
print(f"Year Prediction - MSE: {mse_year_rf:.2f}, R²: {r2_year_rf:.2f}")
print(f"Temperature Prediction - MSE: {mse_temp_rf:.2f}, R²: {r2_temp_rf:.2f}")
print(f"Rainfall Prediction - MSE: {mse_rainfall_rf:.2f}, R²: {r2_rainfall_rf:.2f}")

# Prediction function for new input using Neural Network
def predict_year_temperature_humidity_nn(crop, yield_value):
    yield_squared = yield_value ** 2
    yield_log = np.log1p(yield_value)
    yield_temp_interaction = yield_value * np.mean(y_train['avg_temp'])  # Example interaction term

    input_data = pd.DataFrame({
        'hg/ha_yield': [yield_value],
        'yield_squared': [yield_squared],
        'yield_log': [yield_log],
        'yield_temp_interaction': [yield_temp_interaction],
        'Item': [crop]
    })

    # Preprocess input data
    input_data[numerical_features] = scaler.transform(input_data[numerical_features])
    input_encoded = encoder.transform(input_data[categorical_features]).toarray()
    input_combined = np.hstack([input_data[numerical_features].values, input_encoded])

    # Predict using the trained model
    prediction = nn_model.predict(input_combined)
    predicted_year, predicted_temp, predicted_rainfall = prediction[0]

    return predicted_year, predicted_temp, predicted_rainfall

# Example usage
sample_crop = 'Maize'
sample_yield = 0
predicted_year, predicted_temp, predicted_rainfall = predict_year_temperature_humidity_nn(sample_crop, sample_yield)

print(f"Predicted Year (NN): {int(predicted_year)}")
print(f"Predicted Temperature (NN): {predicted_temp:.2f}°C")
print(f"Predicted Rainfall (Humidity proxy, NN): {predicted_rainfall:.2f} mm/year")

# Example usage
sample_crop = 'Maize'
sample_yield = 0
predicted_year, predicted_temp, predicted_rainfall = predict_year_temperature_humidity_nn(sample_crop, sample_yield)

print(f"Predicted Year (NN): {int(predicted_year)}")
print(f"Predicted Temperature (NN): {predicted_temp:.2f}°C")
print(f"Predicted Rainfall (Humidity proxy, NN): {predicted_rainfall:.2f} mm/year")

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import OneHotEncoder, StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
import tensorflow as tf

# Load the dataset (adjust file path as needed)
file_path = 'yield_df.csv'
yield_df = pd.read_csv(file_path)

# Data Quality Check and Handling Missing Values
yield_df['hg/ha_yield'].fillna(yield_df['hg/ha_yield'].mean(), inplace=True)
yield_df['avg_temp'].fillna(yield_df['avg_temp'].mean(), inplace=True)
yield_df['average_rain_fall_mm_per_year'].fillna(yield_df['average_rain_fall_mm_per_year'].mean(), inplace=True)

# Feature Engineering
yield_df['yield_squared'] = yield_df['hg/ha_yield'] ** 2  # Polynomial feature
yield_df['yield_log'] = np.log1p(yield_df['hg/ha_yield'])  # Log transformation
yield_df['yield_temp_interaction'] = yield_df['hg/ha_yield'] * yield_df['avg_temp']  # Interaction term

# Selecting features (X) and target variables (y)
X = yield_df[['hg/ha_yield', 'yield_squared', 'yield_log', 'yield_temp_interaction', 'Item']]
y_temp_rainfall = yield_df[['avg_temp', 'average_rain_fall_mm_per_year']]
y_year = yield_df[['Year']]

# Preprocessing for numerical and categorical features
numerical_features = ['hg/ha_yield', 'yield_squared', 'yield_log', 'yield_temp_interaction']
categorical_features = ['Item']

scaler = StandardScaler()
X[numerical_features] = scaler.fit_transform(X[numerical_features])

encoder = OneHotEncoder()
X_encoded = encoder.fit_transform(X[categorical_features]).toarray()

X_combined = np.hstack([X[numerical_features].values, X_encoded])

# Train-test split
X_train, X_test, y_train_temp_rainfall, y_test_temp_rainfall = train_test_split(X_combined, y_temp_rainfall, test_size=0.2, random_state=42)
_, _, y_train_year, y_test_year = train_test_split(X_combined, y_year, test_size=0.2, random_state=42)

# Model for Temperature and Rainfall
nn_model_temp_rainfall = tf.keras.Sequential([
    tf.keras.layers.Dense(128, activation='relu', input_shape=(X_train.shape[1],)),
    tf.keras.layers.Dense(64, activation='relu'),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(2)  # Two output values (Temperature and Rainfall)
])

nn_model_temp_rainfall.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                               loss='mse',
                               metrics=['mae'])

# Train the model
nn_model_temp_rainfall.fit(X_train, y_train_temp_rainfall, validation_split=0.2, epochs=100, batch_size=32, verbose=1)

# Model for Year Prediction
nn_model_year = tf.keras.Sequential([
    tf.keras.layers.Dense(64, activation='relu', input_shape=(X_train.shape[1],)),
    tf.keras.layers.Dense(32, activation='relu'),
    tf.keras.layers.Dense(1)  # Single output value (Year)
])

nn_model_year.compile(optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
                      loss='mse',
                      metrics=['mae'])

# Train the model
nn_model_year.fit(X_train, y_train_year, validation_split=0.2, epochs=100, batch_size=32, verbose=1)

# Evaluate the models
loss_temp_rainfall, mae_temp_rainfall = nn_model_temp_rainfall.evaluate(X_test, y_test_temp_rainfall, verbose=0)
loss_year, mae_year = nn_model_year.evaluate(X_test, y_test_year, verbose=0)

# Predictions
y_pred_temp_rainfall = nn_model_temp_rainfall.predict(X_test)
y_pred_year = nn_model_year.predict(X_test)

# Calculate R² Scores
r2_temp = r2_score(y_test_temp_rainfall['avg_temp'], y_pred_temp_rainfall[:, 0])
r2_rainfall = r2_score(y_test_temp_rainfall['average_rain_fall_mm_per_year'], y_pred_temp_rainfall[:, 1])
r2_year = r2_score(y_test_year, y_pred_year)

print("Temperature and Rainfall Model Evaluation Metrics:")
print(f"Temperature Prediction - MSE: {loss_temp_rainfall:.2f}, R²: {r2_temp:.2f}")
print(f"Rainfall Prediction - MSE: {loss_temp_rainfall:.2f}, R²: {r2_rainfall:.2f}")

print("\nYear Prediction Model Evaluation Metrics:")
print(f"Year Prediction - MSE: {loss_year:.2f}, R²: {r2_year:.2f}")

# Example usage
sample_crop = 'Maize'
sample_yield = 0
predicted_year, predicted_temp, predicted_rainfall = predict_year_temperature_humidity_nn(sample_crop, sample_yield)

print(f"Predicted Year (NN): {int(predicted_year)}")
print(f"Predicted Temperature (NN): {predicted_temp:.2f}°C")
print(f"Predicted Rainfall (Humidity proxy, NN): {predicted_rainfall:.2f} mm/year")